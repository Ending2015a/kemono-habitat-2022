# --- built in ---
import os
import copy
# --- 3rd party ---
import habitat
import numpy as np
import torch
import cv2
import copy
import rlchemy
import skimage.morphology
from omegaconf import OmegaConf
import gym
from rlchemy import registry
# --- my module ---
from kemono.utils import geometry
from kemono.utils import image as image_utils
from kemono.agent.plan import Plan
from kemono.agent.control import AgentController
from kemono.envs import DummyEnv
from kemono.envs.wrap import (
  SemanticWrapper,
  SemanticMapBuilderWrapper,
  SemanticMapObserver,
  PrettyRenderer
)
import kemono.envs.wrap.map_builder as mapb

class DelayedIntermediate(gym.Wrapper):
  def __init__(self, env):
    super().__init__(env)
    self._cached_ctx = None

  def reset_exec(self, *args, **kwargs):
    return self.env.reset(*args, **kwargs)

  def reset_cache(self, obs):
    self._cached_ctx = obs

  def reset(self, *args, **kwargs):
    return self._cached_ctx
  
  def step_exec(self, act, *args, **kwargs):
    return self.env.step(act, *args, **kwargs)
  
  def step_cache(self, obs, rew, done, info):
    self._cached_ctx = (obs, rew, done, info)

  def step(self, act, *args, **kwargs):
    return self._cached_ctx

class DelayedInterface(gym.Wrapper):
  def __init__(self, env):
    super().__init__(env)

  def reset(self, *args, **kwargs):
    return self.env.reset_exec(*args, **kwargs)

  def reset_record(self, obs):
    self.env.reset_cache(obs)
    return self.env.reset()

  def step(self, act, *args, **kwargs):
    return self.env.step_exec(act, *args, **kwargs)

  def step_record(self, obs, rew, done, info):
    self.env.step_cache(obs, rew, done, info)
    return self.env.step(0)

def set_seed(seed):
  np.random.seed(seed)
  torch.manual_seed(seed)
  torch.cuda.manual_seed(seed)

def create_dummy_env(conf, habitat_config):
  # create dummy env
  env = DummyEnv.make(conf.env.env_id, habitat_config)
  env = SemanticWrapper(
    env = env,
    **conf.env.semantic
  )
  env = SemanticMapBuilderWrapper(
    env = env,
    **conf.env.semantic_map_builder
  )
  env = SemanticMapObserver(
    env = env,
    **conf.env.semantic_map_observer
  )
  env = DelayedIntermediate(
    env = env
  )
  if conf.visualize.monitoring:
    env = PrettyRenderer(
      env = env,
      **conf.env.pretty_renderer
    )
    env = rlchemy.envs.Monitor(
      env,
      **conf.env.monitor
    )
  env = DelayedInterface(
    env = env
  )
  return env

def create_controller(conf, agent):
  assert 'controller' in conf.agent
  controller = AgentController(copy.deepcopy(conf.agent.controller))
  controller.set_agent(agent)
  return controller

def create_planners(conf, agent):
  planners = []
  for planner_conf in conf.agent.planners:
    planner_conf = copy.deepcopy(planner_conf)
    _type = planner_conf.pop('type')
    planner_class = registry.get.planner(_type)
    planner = planner_class(**planner_conf)
    planner.set_agent(agent)
    planners.append(planner)
  assert len(planners) > 0
  return planners


class KemonoAgent(habitat.Agent):
  def __init__(
    self,
    conf,
    habitat_config: habitat.Config
  ):
    self.conf = conf
    self.habitat_config = habitat_config
    OmegaConf.resolve(self.conf)

    set_seed(self.conf.agent.seed)

    # initialize
    self.timestep = 0
    self.total_episodes = 0

    self._cached_env_ctx = None
    self._need_replan = True
    self._goal_found = False

    # create dummy environment
    self.env = create_dummy_env(self.conf, self.habitat_config)
    # create agent controller
    # the agent controller responsible for deciding actions by
    # following the navigation map generated by the planner
    self.controller = create_controller(self.conf, self)
    # create planners, used to plan long-term goal
    # Note that we use multiple planners to ensure the long-term
    # goal exists
    self.planners = create_planners(self.conf, self)

  @property
  def need_replan(self):
    return self._need_replan

  @property
  def goal_found(self):
    return self._goal_found

  def set_need_replan(self):
    self._need_replan = True

  def reset(self):
    self.timestep = 0
    self.total_episodes += 1

    self._need_replan = True
    self._cached_env_ctx = None
    self._goal_found = False

    self.controller.reset()
    # reset all planners
    for planner in self.planners:
      planner.reset()

  def observe(self, observations):
    self.timestep += 1
    if self.timestep > self.conf.agent.timestep_limit:
      return {'action': 0}
    
    self.env.set_observation(observations)
    if self.timestep == 1:
      obs = self.env.reset()
      self._cached_env_ctx = obs
    else:
      obs, rew, done, info = self.env.step(0)
      self._cached_env_ctx = (obs, rew, done, info)

    self.controller.update_state(observations)

  def react(self, plan: Plan):
    self._need_replan = False
    # make navigation map
    world_map = self.env.get_world_map()
    map_builder = self.env.get_map_builder()

    map_res = map_builder.proj.map_res
    plan_map_res = self.controller.map_res
    plan_map_size = plan.plan_map.shape[0]
    ratio = (plan_map_res / map_res)
    cx = -plan.center_pos[1] / map_res
    cy = -plan.center_pos[0] / map_res
    crop_size = plan_map_size * ratio

    goal_ch = map_builder.goal_channel
    obs_ch = map_builder.obstacle_channel
    free_ch = map_builder.walkable_channel
    layer_ch = map_builder.layer_channel_start
    stair_ch = layer_ch + 1
    struct_ch = layer_ch
    goal_cat_ch = map_builder.goal_cat_channel
    origin = world_map.get_origin()[0]
    nav_map = world_map.select(
      (origin[0]+cx, origin[1]+cy),
      int(crop_size),
      int(crop_size)
    )
    sem_map = mapb.smooth_tensor(
      nav_map.topdown_map[:, :goal_ch], # semantic map
      dilate_size = 3,
      dilate_iter = 2,
      erode_size = 3,
      erode_iter = 1
    ) # (1, c, h, w)
    goal_map = nav_map.topdown_map[0, goal_ch] # (h, w)

    # resize navigation map and ocnvert it to numpy
    size = (plan_map_size, plan_map_size)
    sem_map = image_utils.resize_image(sem_map, size, mode='nearest')
    goal_map = image_utils.resize_image(goal_map, size, mode='nearest')
    # convert to numpy array
    sem_map = sem_map[0].cpu().numpy() # (c, h, w)
    goal_map = goal_map.cpu().numpy()

    # some constants
    threshold = 0.5
    confidence_thres = 0.75
    # binarize semantic map
    sem_map[:layer_ch] = (sem_map[:layer_ch] > threshold).astype(np.float32)
    local_max = sem_map[layer_ch:].max(axis=0, keepdims=True)
    layer_thres = np.maximum(local_max * confidence_thres, threshold)
    sem_map[layer_ch:] = (sem_map[layer_ch:] > layer_thres).astype(np.float32)
    # clean stairs
    stair_map = sem_map[stair_ch]
    struct_map = sem_map[struct_ch]
    # binarize goal map
    goal_map = (goal_map > threshold).astype(np.float32)
    occ_map = sem_map[obs_ch]

    if self.conf.agent.clean_stair_map:
      stair_map = stair_map.astype(bool)
      occ_map = occ_map.astype(bool)
      # dilate
      brush = skimage.morphology.disk(self.conf.agent.stair_dilate_size)
      stair_map = skimage.morphology.binary_dilation(stair_map, brush)
      # erode
      brush = skimage.morphology.disk(self.conf.agent.stair_erode_size)
      stair_map = skimage.morphology.binary_erosion(stair_map, brush)
      # subtract stair map
      occ_map = np.logical_xor(np.logical_and(occ_map, stair_map), occ_map)
      occ_map = occ_map.astype(np.float32)
      sem_map[obs_ch] = occ_map

    # get frontier map
    frontier = geometry.get_frontier_map(
      sem_map[free_ch],
      np.any(sem_map == 1, axis=0)
    ).numpy()

    self._goal_found = np.any(goal_map > 0)
    if not self.goal_found:
      goal_map = plan.plan_map
    else:
      # disable action planning when the object goal was found
      plan.plan_act = None

    # match the planner coordinates (-w, -h)
    sem_map = np.transpose(sem_map, (1, 2, 0)) # (h, w, c)
    _sem_map = np.transpose(sem_map[::-1, ::-1, obs_ch:], (1, 0, 2)) # (-w, -h, c)
    _occ_map = occ_map[::-1, ::-1].T # (-w, -h)
    _goal_map = goal_map[::-1, ::-1].T
    _struct_map = struct_map[::-1, ::-1].T
    _frontier = frontier[::-1, ::-1].T

    action = self.controller.act(
      nav_map = _sem_map,
      goal_map = _goal_map,
      center_pos = plan.center_pos,
      goal_found = self.goal_found,
      struct_map = _struct_map,
      plan_act = plan.plan_act
    )

    if not self.goal_found:
      _goal_map = plan.plan_map[::-1, ::-1].T
    else:
      plan.plan_act = None

    if self.timestep == 1:
      obs = self._cached_env_ctx
    else:
      obs, rew, done, info = self._cached_env_ctx
    
    # visualize navigation map
    if self.conf.visualize.monitoring:
      hex2rgb = image_utils.hex2rgb
      vis_conf = self.conf.visualize.colors
      color_nav_map = np.zeros(occ_map.shape + (3,), dtype=np.uint8)
      # visualize obstacles
      if vis_conf.obstacle_color is not None:
        color_nav_map[occ_map > threshold] = \
          np.array(hex2rgb(vis_conf.obstacle_color), dtype=np.uint8)
      
      if vis_conf.stg_color is not None:
        _goal = np.zeros_like(goal_map)
        _goal[self.controller.stg[0], self.controller.stg[1]] = 1
        _goal = _goal.T[::-1, ::-1]
        brush = skimage.morphology.disk(2)
        _goal = skimage.morphology.binary_dilation(_goal, brush)
        color_nav_map[_goal] = \
            np.array(hex2rgb(vis_conf.stg_color), dtype=np.uint8)

      if self.goal_found:
        # visualize object goal
        if vis_conf.objgoal_color is not None:
          color_nav_map[goal_map > threshold] = \
            np.array(hex2rgb(vis_conf.objgoal_color), dtype=np.uint8)
      else:
        # visualize long-term goal if object goal not found
        if vis_conf.ltg_color is not None:
          brush = skimage.morphology.disk(3)
          _goal = skimage.morphology.binary_dilation(goal_map > threshold, brush)
          color_nav_map[_goal] = \
              np.array(hex2rgb(vis_conf.ltg_color), dtype=np.uint8)
      # visualize frontiers
      if vis_conf.frontier_color is not None:
        color_nav_map[frontier == 1] = \
          np.array(hex2rgb(vis_conf.frontier_color), dtype=np.uint8)
      # visualize collision/visited area
      # Note that the plan_window is set after calling controller.act
      gx1, gx2, gy1, gy2 = self.controller.plan_window

      if vis_conf.collision_color is not None:
        colmap = self.controller.collision_map[gx1:gx2, gy1:gy2]
        color_nav_map[colmap.T[::-1, ::-1] == 1] = \
          np.array(hex2rgb(vis_conf.collision_color), dtype=np.uint8)

      if vis_conf.visited_color is not None:
        vismap = self.controller.visited_map[gx1:gx2, gy1:gy2]
        color_nav_map[vismap.T[::-1, ::-1] == 1] = \
          np.array(hex2rgb(vis_conf.visited_color), dtype=np.uint8)

      obs['nav_map'] = color_nav_map
    
    if self.timestep == 1:
      self.env.reset_record(obs)
    else:
      self.env.step_record(obs, rew, done, info)

    # render scene
    if self.conf.visualize.render_scene:
      res = self.visualize()
      if res is not None:
        self.controller.action_deque[-1] = res
        self.controller.last_action = res
        action = {'action': res}

    return action

  def get_plan(self, observations):
    final = Plan()
    for planner in self.planners:
      plan = planner.act(observations)
      # fill in plan map
      if final.plan_map is None:
        final.plan_map = plan.plan_map
        final.center_pos = plan.center_pos
      # fill in plan act
      if final.plan_act is None:
        final.plan_act = plan.plan_act

    assert final.plan_map is not None
    return final

  def act(self, observations):
    self.observe(observations)
    plan = self.get_plan(observations)
    action = self.react(plan)
    return action

  def visualize(self):
    self.env.render(mode='human', scale=0.7)
    if self.conf.visualize.interact:
      self.env.render(mode='interact')
    if self.conf.visualize.keyboard:
      while True:
        key = cv2.waitKey(0)
        if key == ord('w'):
          return 1
        elif key == ord('a'):
          return 2
        elif key == ord('d'):
          return 3
        elif key == ord('f'):
          return 0
        elif key == ord('q'):
          exit(0)
        elif key == ord(' '):
          return
        else:
          print(f'INVALID KEY: {key}')
          continue
    if self.conf.visualize.waitKey >= 0:
      cv2.waitKey(self.conf.waitKey)